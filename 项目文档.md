## 从零手搓一个简化版分布式文件存储系统

### 1. 项目目标与功能范围

- **目标**：实现一个简化版“网盘后端”（仿百度网盘），支持：
  - **用户系统**：注册、登录、登录态校验（token）
  - **文件能力**：
    - 普通上传 / 下载
    - 文件元数据管理（文件名、hash、大小、存储位置等）
    - 秒传（基于文件 hash）
    - （进阶）分块上传 / 断点续传
  - **存储与基础设施**：
    - MySQL 存文件元数据、用户信息和用户文件关系
    - （进阶）Redis 存分块上传状态
    - 本地文件系统保存文件内容（后续可扩展到 OSS/Ceph）
    - （进阶）RabbitMQ 做异步转存

> 建议实现顺序：先完成 **用户 + 普通上传下载 + 秒传 + MySQL**，再逐步叠加分块上传、Redis、OSS、RabbitMQ。

---

### 2. 技术选型

- **语言**：Go
- **Web 后端**：标准库 `net/http` 提供 RESTful API
- **数据库**：MySQL
- **缓存（可选）**：Redis
- **消息队列（可选）**：RabbitMQ
- **前端**：独立的 Vue 单页应用（登录、注册、上传、列表页），通过 HTTP 调用后端 API

---

### 3. 项目结构设计

建议目录结构（示例）：

```text
filestore/
├── cmd/
│   ├── upload/         # 上传/主 Web 服务入口（纯后端 API）
│   │   └── main.go
│   └── transfer/       # 异步转存服务入口（可选）
│       └── main.go
├── config/             # 配置（DB、Redis、存储类型等）
├── internal/
│   ├── handler/        # HTTP handler（user、file、mpupload 等）
│   ├── db/             # 数据访问层（user、file、userfile）
│   ├── meta/           # 文件元信息抽象
│   ├── store/          # 存储实现（local、oss、ceph）
│   ├── mq/             # RabbitMQ 封装（可选）
│   └── cache/redis/    # Redis 连接（可选）
└── go.mod

frontend/
├── package.json
├── src/                # Vue 前端工程代码
└── ...
```

可以参考当前仓库结构，但自己新建一套“最小结构”更有利于理解。

---

### 4. 步骤一：初始化 Go 项目

```bash
mkdir filestore
cd filestore

go mod init filestore

mkdir -p cmd/upload internal/{handler,db,meta,store,cache,cache/redis,mq} static
```

---

### 5. 步骤二：数据库设计（DDL）

最小需要 3 张表：

1. **用户表 `tbl_user`**
2. **文件唯一表 `tbl_file`**
3. **用户-文件关系表 `tbl_user_file`**

示例 DDL（简化版）：

```sql
CREATE TABLE tbl_user (
  id           INT AUTO_INCREMENT PRIMARY KEY,
  user_name    VARCHAR(64) NOT NULL UNIQUE,
  user_pwd     VARCHAR(256) NOT NULL,
  signup_at    DATETIME DEFAULT CURRENT_TIMESTAMP,
  last_active  DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE tbl_file (
  id         INT AUTO_INCREMENT PRIMARY KEY,
  file_sha1  CHAR(40) NOT NULL UNIQUE,
  file_name  VARCHAR(256) NOT NULL,
  file_size  BIGINT DEFAULT 0,
  file_addr  VARCHAR(1024) NOT NULL,
  status     INT NOT NULL DEFAULT 0
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE tbl_user_file (
  id          INT AUTO_INCREMENT PRIMARY KEY,
  user_name   VARCHAR(64) NOT NULL,
  file_sha1   CHAR(40) NOT NULL,
  file_size   BIGINT DEFAULT 0,
  file_name   VARCHAR(256) NOT NULL,
  upload_at   DATETIME DEFAULT CURRENT_TIMESTAMP,
  last_update DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  status      INT NOT NULL DEFAULT 0,
  UNIQUE KEY idx_user_file (user_name, file_sha1)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

执行顺序：

1. 创建数据库

   ```sql
   CREATE DATABASE fileserver DEFAULT CHARACTER SET utf8mb4;
   ```

2. 切换数据库并建表

   ```sql
   USE fileserver;
   -- 执行上面的三段 CREATE TABLE
   ```

---

### 6. 步骤三：配置与 DB 连接

#### 6.1 配置文件示例（`config/db.go`）

```go
package config

const (
    MySQLDSN = "root:你的密码@tcp(127.0.0.1:3306)/fileserver?charset=utf8mb4&parseTime=true"
)
```

#### 6.2 数据库初始化（`internal/db/mysql.go`）

```go
package db

import (
    "database/sql"
    "log"

    _ "github.com/go-sql-driver/mysql"
    "filestore/config"
)

var DB *sql.DB

func Init() {
    var err error
    DB, err = sql.Open("mysql", config.MySQLDSN)
    if err != nil {
        log.Fatal("open db failed:", err)
    }
    if err = DB.Ping(); err != nil {
        log.Fatal("ping db failed:", err)
    }
}
```

之后所有 `db/user.go`、`db/file.go` 都通过 `db.DB` 访问数据库。

---

### 7. 步骤四：主服务入口（上传服务）

`cmd/upload/main.go` 示例：

```go
package main

import (
    "fmt"
    "net/http"

    "filestore/internal/db"
    "filestore/internal/handler"
)

func main() {
    db.Init()

    // 用户接口
    http.HandleFunc("/user/signup", handler.SignupHandler)
    http.HandleFunc("/user/signin", handler.SigninHandler)
    http.HandleFunc("/user/info", handler.Auth(handler.UserInfoHandler))

    // 文件接口
    http.HandleFunc("/file/upload", handler.Auth(handler.UploadHandler))
    http.HandleFunc("/file/download", handler.Auth(handler.DownloadHandler))
    http.HandleFunc("/file/meta", handler.Auth(handler.FileMetaHandler))
    http.HandleFunc("/file/fastupload", handler.Auth(handler.FastUploadHandler))

    addr := ":8080"
    fmt.Println("server listening on", addr)
    if err := http.ListenAndServe(addr, nil); err != nil {
        panic(err)
    }
}
```

---

### 8. 步骤五：用户模块（注册 / 登录 / token）

#### 8.1 用户 DAO（`internal/db/user.go`）

```go
package db

import "context"

type User struct {
    UserName string
    UserPwd  string
}

func InsertUser(ctx context.Context, username, encPwd string) error {
    _, err := DB.ExecContext(ctx,
        "INSERT INTO tbl_user (user_name, user_pwd) VALUES (?, ?)",
        username, encPwd)
    return err
}

func GetUserByName(ctx context.Context, username string) (*User, error) {
    u := &User{}
    err := DB.QueryRowContext(ctx,
        "SELECT user_name, user_pwd FROM tbl_user WHERE user_name=? LIMIT 1",
        username).Scan(&u.UserName, &u.UserPwd)
    if err != nil {
        return nil, err
    }
    return u, nil
}
```

#### 8.2 用户 Handler（`internal/handler/user.go` 核心逻辑）

```go
func SignupHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        w.WriteHeader(http.StatusMethodNotAllowed)
        return
    }
    username := r.FormValue("username")
    password := r.FormValue("password")

    // TODO: 参数校验、密码加盐后 hash
    encPwd := password

    if err := db.InsertUser(r.Context(), username, encPwd); err != nil {
        w.WriteHeader(http.StatusInternalServerError)
        return
    }
    w.Write([]byte("ok"))
}

func SigninHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        w.WriteHeader(http.StatusMethodNotAllowed)
        return
    }
    username := r.FormValue("username")
    password := r.FormValue("password")

    u, err := db.GetUserByName(r.Context(), username)
    if err != nil || u.UserPwd != password {
        w.WriteHeader(http.StatusUnauthorized)
        return
    }

    token := GenToken(username)

    resp := map[string]string{
        "username": username,
        "token":    token,
    }
    _ = json.NewEncoder(w).Encode(resp)
}
```

#### 8.3 鉴权拦截器（`internal/handler/auth.go`）

```go
func Auth(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        username := r.FormValue("username")
        token := r.FormValue("token")
        if !ValidateToken(username, token) {
            w.WriteHeader(http.StatusUnauthorized)
            return
        }
        next(w, r)
    }
}
```

`GenToken` / `ValidateToken` 可以先用简单实现，后续再逐步加密和存表。

---

### 9. 步骤六：文件元数据与上传下载

#### 9.1 文件元数据结构（`internal/meta/filemeta.go`）

```go
package meta

type FileMeta struct {
    FileSha1 string
    FileName string
    FileSize int64
    Location string
}
```

#### 9.2 文件 DAO（`internal/db/file.go`）

```go
func InsertFileMeta(ctx context.Context, fm *meta.FileMeta) error {
    _, err := DB.ExecContext(ctx,
        "INSERT INTO tbl_file (file_sha1, file_name, file_size, file_addr) VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE status=0",
        fm.FileSha1, fm.FileName, fm.FileSize, fm.Location)
    return err
}

func GetFileMeta(ctx context.Context, sha1 string) (*meta.FileMeta, error) {
    fm := &meta.FileMeta{}
    err := DB.QueryRowContext(ctx,
        "SELECT file_sha1, file_name, file_size, file_addr FROM tbl_file WHERE file_sha1=? AND status=0 LIMIT 1",
        sha1).Scan(&fm.FileSha1, &fm.FileName, &fm.FileSize, &fm.Location)
    if err != nil {
        return nil, err
    }
    return fm, nil
}
```

用户文件关系 DAO (`internal/db/userfile.go`) 负责往 `tbl_user_file` 写入记录。

#### 9.3 上传 Handler 核心逻辑（`internal/handler/file.go`）

```go
func UploadHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        w.WriteHeader(http.StatusMethodNotAllowed)
        return
    }

    file, head, err := r.FormFile("file")
    if err != nil {
        w.WriteHeader(http.StatusBadRequest)
        return
    }
    defer file.Close()

    localPath := "/tmp/" + head.Filename
    f, err := os.Create(localPath)
    if err != nil {
        w.WriteHeader(http.StatusInternalServerError)
        return
    }
    defer f.Close()

    n, err := io.Copy(f, file)
    if err != nil {
        w.WriteHeader(http.StatusInternalServerError)
        return
    }

    if _, err := f.Seek(0, 0); err != nil {
        w.WriteHeader(http.StatusInternalServerError)
        return
    }
    sha1 := CalcFileSha1(f)

    fm := &meta.FileMeta{
        FileSha1: sha1,
        FileName: head.Filename,
        FileSize: n,
        Location: localPath,
    }
    if err := db.InsertFileMeta(r.Context(), fm); err != nil {
        w.WriteHeader(http.StatusInternalServerError)
        return
    }

    username := r.FormValue("username")
    if err := db.InsertUserFile(r.Context(), username, fm); err != nil {
        w.WriteHeader(http.StatusInternalServerError)
        return
    }

    w.Write([]byte("ok"))
}
```

#### 9.4 下载 Handler 核心逻辑

```go
func DownloadHandler(w http.ResponseWriter, r *http.Request) {
    filehash := r.URL.Query().Get("filehash")
    fm, err := db.GetFileMeta(r.Context(), filehash)
    if err != nil {
        w.WriteHeader(http.StatusNotFound)
        return
    }

    f, err := os.Open(fm.Location)
    if err != nil {
        w.WriteHeader(http.StatusInternalServerError)
        return
    }
    defer f.Close()

    w.Header().Set("Content-Type", "application/octet-stream")
    w.Header().Set("Content-Disposition", "attachment; filename=\""+fm.FileName+"\"")
    io.Copy(w, f)
}
```

---

### 10. 步骤七：秒传逻辑

**核心思想**：

1. 客户端计算文件 hash（或上传前请求）
2. 后端查询 `tbl_file` 是否已有该 hash 的记录
3. 如有：只在 `tbl_user_file` 插入一条记录，不再重复上传

秒传 Handler 示例：

```go
func FastUploadHandler(w http.ResponseWriter, r *http.Request) {
    username := r.FormValue("username")
    filehash := r.FormValue("filehash")
    filename := r.FormValue("filename")

    fm, err := db.GetFileMeta(r.Context(), filehash)
    if err != nil || fm == nil {
        w.WriteHeader(http.StatusNotFound)
        w.Write([]byte("fast upload failed, please use normal upload"))
        return
    }

    if err := db.InsertUserFile(r.Context(), username, &meta.FileMeta{
        FileSha1: filehash,
        FileName: filename,
        FileSize: fm.FileSize,
        Location: fm.Location,
    }); err != nil {
        w.WriteHeader(http.StatusInternalServerError)
        return
    }

    w.Write([]byte("fast upload success"))
}
```

---

### 11. 步骤八：分块上传 / Redis（进阶）

分块上传主要有三类接口：

1. **初始化** `/file/mpupload/init`：
   - 根据文件大小计算 `chunkCount`
   - 生成 `uploadID`
   - 在 Redis 中写入：
     - `HSET MP_<uploadID> chunkcount <N>`
     - `HSET MP_<uploadID> filehash <hash>`

2. **上传块** `/file/mpupload/uppart`：
   - 参数：`uploadid`、`index`
   - 将分块写入：`/data/<uploadID>/<index>`
   - 在 Redis 中标记：`HSET MP_<uploadID> chkidx_<index> 1`

3. **合并** `/file/mpupload/complete`：
   - 从 Redis `HGETALL MP_<uploadID>` 获取所有字段
   - 统计 `chunkCount` 和 `chkidx_*` 个数对比
   - 依次读取 `/data/<uploadID>/<index>` 合并成最终文件
   - 计算 hash，写入 `tbl_file` 和 `tbl_user_file`

这里可以直接参考现有项目的 `handler/mpupload.go`，按逻辑逐步实现。

---

### 12. 步骤九：存储抽象与对象存储（进阶）

抽象一个存储接口：

```go
type Store interface {
    Save(localPath, objectKey string) error
    Download(objectKey string) (io.ReadCloser, error)
}
```

实现几种后端：

- **本地存储**：`store/local`，直接对接本地文件
- **OSS 存储**：`store/oss`，调用 OSS SDK
- **Ceph 存储**：`store/ceph`，调用 S3 兼容接口

在上传逻辑中通过配置选择：

```go
switch config.CurrentStoreType {
case config.StoreLocal:
    // 已经存本地
case config.StoreOSS:
    // 同步：直接调用 OSS
    // 异步：写 MQ 交给 transfer 服务
}
```

---

### 13. 步骤十：异步转存服务（进阶）

新建 `cmd/transfer/main.go`，核心流程：

1. 连接 RabbitMQ，监听队列（如 `upload.trans.oss`）
2. 消息体结构：

   ```go
   type TransferData struct {
       FileHash     string
       CurLocation  string
       DestLocation string
   }
   ```

3. 每条消息处理：
   - 从 `CurLocation` 打开本地文件
   - 写入 OSS 的 `DestLocation`
   - 更新 `tbl_file.file_addr` 为 `DestLocation`

这样上传服务只负责写本地 + 发送 MQ 消息，耗时的对象存储写入由 transfer 服务异步完成。

---

### 14. 实践路线建议

1. **第一阶段**：
   - 搭建项目结构
   - 完成 DB 连接
   - 实现用户注册 / 登录 / 简单 token
   - 实现普通上传 / 下载 + 元数据 / 用户文件记录
   - 用 Postman 或 curl 自测接口

2. **第二阶段**：
   - 实现秒传（基于 hash）
   - 前端配合支持秒传请求

3. **第三阶段（进阶）**：
   - 分块上传 + Redis 状态
   - 存储抽象 + OSS/Ceph
   - RabbitMQ + transfer 服务实现异步转存

每完成一个阶段，建议画出“请求 → handler → db/meta/store/mq”的调用链，检查逻辑是否闭环，再继续下一个阶段。
